<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MIDI Timestamp Tester</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        h1 {
            color: #333;
            text-align: center;
        }
        h2 {
            color: #555;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
        }
        label {
            font-weight: bold;
            margin-bottom: 5px;
            color: #333;
        }
        select, input, button {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }
        button.stop {
            background-color: #dc3545;
        }
        button.stop:hover {
            background-color: #c82333;
        }
        button.clear {
            background-color: #6c757d;
        }
        button.clear:hover {
            background-color: #545b62;
        }
        .status {
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            font-weight: bold;
        }
        .status.success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .status.error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .status.warning {
            background-color: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
        .status.info {
            background-color: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        .results {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        .metric {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 4px;
            text-align: center;
            border-left: 4px solid #007bff;
        }
        .metric.error {
            border-left-color: #dc3545;
        }
        .metric.warning {
            border-left-color: #ffc107;
        }
        .metric.success {
            border-left-color: #28a745;
        }
        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #333;
        }
        .metric-label {
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
        }
        .log {
            background: #1e1e1e;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-break: break-all;
        }
        .timestamp-chart {
            margin: 20px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 4px;
        }
        .chart-bar {
            display: flex;
            align-items: center;
            margin: 5px 0;
            font-size: 12px;
        }
        .chart-label {
            width: 100px;
            flex-shrink: 0;
        }
        .chart-value {
            flex: 1;
            height: 20px;
            background: linear-gradient(90deg, #28a745 0%, #ffc107 50%, #dc3545 100%);
            margin: 0 10px;
            border-radius: 2px;
            position: relative;
        }
        .chart-text {
            width: 80px;
            text-align: right;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h1>MIDI Timestamp Precision Tester</h1>

    <div class="container">
        <h2>Configuration</h2>
        <div class="controls">
            <div class="control-group">
                <label for="inputSelect">MIDI Input:</label>
                <select id="inputSelect">
                    <option value="">Select input device...</option>
                </select>
            </div>
            <div class="control-group">
                <label for="outputSelect">MIDI Output:</label>
                <select id="outputSelect">
                    <option value="">Select output device...</option>
                </select>
            </div>
            <div class="control-group">
                <label for="testDuration">Test Duration (ms):</label>
                <input type="number" id="testDuration" value="5000" min="1000" max="30000" step="100">
            </div>
            <div class="control-group">
                <label for="messageInterval">Message Interval (ms):</label>
                <input type="number" id="messageInterval" value="100" min="10" max="1000" step="10">
            </div>
            <div class="control-group">
                <label for="toleranceMs">Tolerance (ms):</label>
                <input type="number" id="toleranceMs" value="5" min="0.1" max="50" step="0.1">
            </div>
            <div class="control-group">
                <label for="testType">Test Type:</label>
                <select id="testType">
                    <option value="scheduled">Scheduled Messages</option>
                    <option value="immediate">Immediate Messages</option>
                    <option value="mixed">Mixed Timing</option>
                </select>
            </div>
        </div>

        <div class="controls">
            <button id="requestAccess">Request MIDI Access</button>
            <button id="startTest" disabled>Start Timestamp Test</button>
            <button id="stopTest" class="stop" disabled>Stop Test</button>
            <button id="clearLog" class="clear">Clear Log</button>
        </div>

        <div id="status" class="status info">Click "Request MIDI Access" to begin</div>
    </div>

    <div class="container">
        <h2>Test Results</h2>
        <div class="results">
            <div class="metric">
                <div class="metric-value" id="messagesSent">0</div>
                <div class="metric-label">Messages Sent</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="messagesReceived">0</div>
                <div class="metric-label">Messages Received</div>
            </div>
            <div class="metric" id="avgLatencyMetric">
                <div class="metric-value" id="avgLatency">0</div>
                <div class="metric-label">Avg Latency (ms)</div>
            </div>
            <div class="metric" id="maxLatencyMetric">
                <div class="metric-value" id="maxLatency">0</div>
                <div class="metric-label">Max Latency (ms)</div>
            </div>
            <div class="metric" id="minLatencyMetric">
                <div class="metric-value" id="minLatency">0</div>
                <div class="metric-label">Min Latency (ms)</div>
            </div>
            <div class="metric" id="jitterMetric">
                <div class="metric-value" id="jitter">0</div>
                <div class="metric-label">Jitter (ms)</div>
            </div>
            <div class="metric" id="earlyMessagesMetric">
                <div class="metric-value" id="earlyMessages">0</div>
                <div class="metric-label">Early Messages</div>
            </div>
            <div class="metric" id="lateMessagesMetric">
                <div class="metric-value" id="lateMessages">0</div>
                <div class="metric-label">Late Messages</div>
            </div>
        </div>

        <div class="timestamp-chart">
            <h3>Timing Distribution</h3>
            <div id="timingChart"></div>
        </div>
    </div>

    <div class="container">
        <h2>Detailed Log</h2>
        <div id="log" class="log">Waiting for test to start...</div>
    </div>

    <script>
        class MIDITimestampTester {
            constructor() {
                this.midiAccess = null;
                this.selectedInput = null;
                this.selectedOutput = null;
                this.testRunning = false;
                this.testStartTime = 0;
                this.sentMessages = [];
                this.receivedMessages = [];
                this.messageCounter = 0;
                this.testInterval = null;

                this.initializeUI();
            }

            initializeUI() {
                document.getElementById('requestAccess').addEventListener('click', () => this.requestMIDIAccess());
                document.getElementById('startTest').addEventListener('click', () => this.startTest());
                document.getElementById('stopTest').addEventListener('click', () => this.stopTest());
                document.getElementById('clearLog').addEventListener('click', () => this.clearLog());

                document.getElementById('inputSelect').addEventListener('change', (e) => this.selectInput(e.target.value));
                document.getElementById('outputSelect').addEventListener('change', (e) => this.selectOutput(e.target.value));
            }

            log(message, type = 'info') {
                const timestamp = new Date().toISOString().substr(11, 12);
                const logEl = document.getElementById('log');
                const typePrefix = type.toUpperCase().padEnd(5);
                logEl.textContent += `[${timestamp}] ${typePrefix}: ${message}\n`;
                logEl.scrollTop = logEl.scrollHeight;

                console.log(`[MIDI Tester ${type}]`, message);
            }

            setStatus(message, type = 'info') {
                const statusEl = document.getElementById('status');
                statusEl.textContent = message;
                statusEl.className = `status ${type}`;
            }

            async requestMIDIAccess() {
                try {
                    this.setStatus('Requesting MIDI access...', 'info');
                    this.log('Requesting MIDI access with sysex support');

                    this.midiAccess = await navigator.requestMIDIAccess({ sysex: true });

                    this.log(`MIDI access granted. Inputs: ${this.midiAccess.inputs.size}, Outputs: ${this.midiAccess.outputs.size}`);
                    this.setStatus('MIDI access granted! Select input and output devices.', 'success');

                    this.populateDeviceSelectors();

                    // Listen for device changes
                    this.midiAccess.addEventListener('statechange', (e) => {
                        this.log(`Device state change: ${e.port.name} - ${e.port.state}`, 'info');
                        this.populateDeviceSelectors();
                    });

                } catch (error) {
                    this.log(`Failed to request MIDI access: ${error.message}`, 'error');
                    this.setStatus(`MIDI access denied: ${error.message}`, 'error');
                }
            }

            populateDeviceSelectors() {
                const inputSelect = document.getElementById('inputSelect');
                const outputSelect = document.getElementById('outputSelect');

                // Clear existing options (except first)
                inputSelect.innerHTML = '<option value="">Select input device...</option>';
                outputSelect.innerHTML = '<option value="">Select output device...</option>';

                // Populate inputs
                this.midiAccess.inputs.forEach((input) => {
                    const option = document.createElement('option');
                    option.value = input.id;
                    option.textContent = `${input.name} (${input.state})`;
                    inputSelect.appendChild(option);
                });

                // Populate outputs
                this.midiAccess.outputs.forEach((output) => {
                    const option = document.createElement('option');
                    option.value = output.id;
                    option.textContent = `${output.name} (${output.state})`;
                    outputSelect.appendChild(option);
                });
            }

            async selectInput(inputId) {
                if (!inputId) {
                    this.selectedInput = null;
                    this.updateTestButtonState();
                    return;
                }

                this.selectedInput = this.midiAccess.inputs.get(inputId);
                if (this.selectedInput) {
                    await this.selectedInput.open();
                    this.selectedInput.onmidimessage = (e) => this.handleMIDIMessage(e);
                    this.log(`Input selected and opened: ${this.selectedInput.name}`);
                }

                this.updateTestButtonState();
            }

            async selectOutput(outputId) {
                if (!outputId) {
                    this.selectedOutput = null;
                    this.updateTestButtonState();
                    return;
                }

                this.selectedOutput = this.midiAccess.outputs.get(outputId);
                if (this.selectedOutput) {
                    await this.selectedOutput.open();
                    this.log(`Output selected and opened: ${this.selectedOutput.name}`);
                }

                this.updateTestButtonState();
            }

            updateTestButtonState() {
                const canTest = this.selectedInput && this.selectedOutput && !this.testRunning;
                document.getElementById('startTest').disabled = !canTest;
                document.getElementById('stopTest').disabled = !this.testRunning;
            }

            handleMIDIMessage(event) {
                if (!this.testRunning) return;

                const receivedTime = performance.now();
                const data = Array.from(event.data);

                // Look for our test message pattern (Control Change on channel 1)
                if (data.length >= 3 && data[0] === 0xB0) {
                    const cc = data[1];
                    const value = data[2];

                    // CC 120 is our test marker
                    if (cc === 120) {
                        const messageId = value;
                        const sentMessage = this.sentMessages.find(msg => msg.id === messageId);

                        if (sentMessage) {
                            const latency = receivedTime - sentMessage.scheduledTime;
                            const earlyLatency = receivedTime - sentMessage.sentTime;

                            const receivedMessage = {
                                id: messageId,
                                receivedTime: receivedTime,
                                scheduledTime: sentMessage.scheduledTime,
                                sentTime: sentMessage.sentTime,
                                latency: latency,
                                earlyLatency: earlyLatency,
                                eventTimestamp: event.timeStamp || event.receivedTime,
                                data: data
                            };

                            this.receivedMessages.push(receivedMessage);

                            // Check if message arrived early (before scheduled time)
                            const isEarly = receivedTime < sentMessage.scheduledTime - parseFloat(document.getElementById('toleranceMs').value);

                            if (isEarly) {
                                this.log(`⚠️  EARLY MESSAGE ${messageId}: arrived ${(sentMessage.scheduledTime - receivedTime).toFixed(2)}ms early`, 'warning');
                            } else {
                                this.log(`✓ Message ${messageId}: latency ${latency.toFixed(2)}ms, early by ${earlyLatency.toFixed(2)}ms`);
                            }

                            this.updateResults();
                        } else {
                            this.log(`❌ Received unexpected message with ID ${messageId}`, 'error');
                        }
                    }
                }
            }

            async startTest() {
                if (this.testRunning) return;

                this.testRunning = true;
                this.updateTestButtonState();

                // Reset test data
                this.sentMessages = [];
                this.receivedMessages = [];
                this.messageCounter = 0;
                this.testStartTime = performance.now();

                const duration = parseInt(document.getElementById('testDuration').value);
                const interval = parseInt(document.getElementById('messageInterval').value);
                const testType = document.getElementById('testType').value;

                this.log(`Starting timestamp test (${testType}) for ${duration}ms with ${interval}ms intervals`);
                this.setStatus(`Test running... (${testType})`, 'info');

                // Schedule test messages
                this.scheduleTestMessages(duration, interval, testType);

                // Auto-stop after duration + buffer
                setTimeout(() => {
                    if (this.testRunning) {
                        this.stopTest();
                    }
                }, duration + 2000);
            }

            scheduleTestMessages(duration, interval, testType) {
                const startTime = performance.now();
                let currentTime = startTime;

                const sendMessage = () => {
                    if (!this.testRunning || (performance.now() - startTime) > duration) {
                        return;
                    }

                    const messageId = this.messageCounter % 128; // Keep within MIDI value range
                    let scheduledTime;

                    switch (testType) {
                        case 'immediate':
                            scheduledTime = undefined; // Send immediately
                            break;
                        case 'scheduled':
                            scheduledTime = currentTime;
                            break;
                        case 'mixed':
                            // Alternate between immediate and scheduled
                            scheduledTime = (this.messageCounter % 2 === 0) ? currentTime : undefined;
                            break;
                    }

                    const sentTime = performance.now();

                    // Send CC message: Channel 1, CC 120 (test marker), Value = message ID
                    const message = [0xB0, 120, messageId];

                    try {
                        if (scheduledTime !== undefined) {
                            this.selectedOutput.send(message, scheduledTime);
                            this.log(`→ Scheduled message ${messageId} for ${(scheduledTime - performance.timeOrigin).toFixed(2)}ms`);
                        } else {
                            this.selectedOutput.send(message);
                            this.log(`→ Sent immediate message ${messageId}`);
                        }

                        this.sentMessages.push({
                            id: messageId,
                            sentTime: sentTime,
                            scheduledTime: scheduledTime || sentTime,
                            data: message
                        });

                        this.messageCounter++;

                    } catch (error) {
                        this.log(`❌ Failed to send message ${messageId}: ${error.message}`, 'error');
                    }

                    currentTime += interval;

                    // Schedule next message
                    setTimeout(sendMessage, interval);
                };

                // Start sending messages
                sendMessage();
            }

            stopTest() {
                if (!this.testRunning) return;

                this.testRunning = false;
                this.updateTestButtonState();

                if (this.testInterval) {
                    clearInterval(this.testInterval);
                    this.testInterval = null;
                }

                this.log('Test stopped');
                this.setStatus('Test completed. Check results below.', 'success');

                // Final results update
                setTimeout(() => this.updateResults(), 500);
                this.generateFinalReport();
            }

            updateResults() {
                const sent = this.sentMessages.length;
                const received = this.receivedMessages.length;

                document.getElementById('messagesSent').textContent = sent;
                document.getElementById('messagesReceived').textContent = received;

                if (received === 0) return;

                const latencies = this.receivedMessages.map(msg => msg.latency);
                const avgLatency = latencies.reduce((sum, lat) => sum + lat, 0) / latencies.length;
                const minLatency = Math.min(...latencies);
                const maxLatency = Math.max(...latencies);

                // Calculate jitter (standard deviation of latencies)
                const variance = latencies.reduce((sum, lat) => sum + Math.pow(lat - avgLatency, 2), 0) / latencies.length;
                const jitter = Math.sqrt(variance);

                const tolerance = parseFloat(document.getElementById('toleranceMs').value);
                const earlyMessages = this.receivedMessages.filter(msg =>
                    msg.receivedTime < msg.scheduledTime - tolerance
                ).length;
                const lateMessages = this.receivedMessages.filter(msg =>
                    msg.latency > tolerance
                ).length;

                // Update display
                document.getElementById('avgLatency').textContent = avgLatency.toFixed(2);
                document.getElementById('minLatency').textContent = minLatency.toFixed(2);
                document.getElementById('maxLatency').textContent = maxLatency.toFixed(2);
                document.getElementById('jitter').textContent = jitter.toFixed(2);
                document.getElementById('earlyMessages').textContent = earlyMessages;
                document.getElementById('lateMessages').textContent = lateMessages;

                // Color-code metrics based on performance
                this.updateMetricColors(avgLatency, maxLatency, jitter, earlyMessages, lateMessages);
                this.updateTimingChart();
            }

            updateMetricColors(avgLatency, maxLatency, jitter, earlyMessages, lateMessages) {
                const tolerance = parseFloat(document.getElementById('toleranceMs').value);

                // Average latency
                const avgMetric = document.getElementById('avgLatencyMetric');
                if (avgLatency < tolerance) {
                    avgMetric.className = 'metric success';
                } else if (avgLatency < tolerance * 2) {
                    avgMetric.className = 'metric warning';
                } else {
                    avgMetric.className = 'metric error';
                }

                // Max latency
                const maxMetric = document.getElementById('maxLatencyMetric');
                if (maxLatency < tolerance * 2) {
                    maxMetric.className = 'metric success';
                } else if (maxLatency < tolerance * 4) {
                    maxMetric.className = 'metric warning';
                } else {
                    maxMetric.className = 'metric error';
                }

                // Jitter
                const jitterMetric = document.getElementById('jitterMetric');
                if (jitter < tolerance) {
                    jitterMetric.className = 'metric success';
                } else if (jitter < tolerance * 2) {
                    jitterMetric.className = 'metric warning';
                } else {
                    jitterMetric.className = 'metric error';
                }

                // Early messages (should be 0)
                const earlyMetric = document.getElementById('earlyMessagesMetric');
                if (earlyMessages === 0) {
                    earlyMetric.className = 'metric success';
                } else {
                    earlyMetric.className = 'metric error';
                }

                // Late messages
                const lateMetric = document.getElementById('lateMessagesMetric');
                if (lateMessages === 0) {
                    lateMetric.className = 'metric success';
                } else if (lateMessages < this.receivedMessages.length * 0.1) {
                    lateMetric.className = 'metric warning';
                } else {
                    lateMetric.className = 'metric error';
                }
            }

            updateTimingChart() {
                const chartEl = document.getElementById('timingChart');
                if (this.receivedMessages.length === 0) return;

                const latencies = this.receivedMessages.map(msg => msg.latency);
                const minLat = Math.min(...latencies);
                const maxLat = Math.max(...latencies);
                const range = maxLat - minLat;

                // Create histogram bins
                const bins = 10;
                const binSize = range / bins;
                const histogram = new Array(bins).fill(0);

                latencies.forEach(lat => {
                    const binIndex = Math.min(Math.floor((lat - minLat) / binSize), bins - 1);
                    histogram[binIndex]++;
                });

                const maxCount = Math.max(...histogram);

                chartEl.innerHTML = '';
                histogram.forEach((count, index) => {
                    const binStart = minLat + index * binSize;
                    const binEnd = binStart + binSize;
                    const percentage = (count / maxCount) * 100;

                    const barEl = document.createElement('div');
                    barEl.className = 'chart-bar';
                    barEl.innerHTML = `
                        <div class="chart-label">${binStart.toFixed(1)}-${binEnd.toFixed(1)}ms</div>
                        <div class="chart-value" style="width: ${percentage}%"></div>
                        <div class="chart-text">${count} msgs</div>
                    `;
                    chartEl.appendChild(barEl);
                });
            }

            generateFinalReport() {
                if (this.receivedMessages.length === 0) return;

                const tolerance = parseFloat(document.getElementById('toleranceMs').value);
                const earlyMessages = this.receivedMessages.filter(msg =>
                    msg.receivedTime < msg.scheduledTime - tolerance
                );

                this.log('\n=== FINAL TIMESTAMP TEST REPORT ===');
                this.log(`Total messages sent: ${this.sentMessages.length}`);
                this.log(`Total messages received: ${this.receivedMessages.length}`);
                this.log(`Message loss: ${((this.sentMessages.length - this.receivedMessages.length) / this.sentMessages.length * 100).toFixed(1)}%`);

                if (earlyMessages.length > 0) {
                    this.log(`\n⚠️  TIMING VIOLATIONS DETECTED:`);
                    this.log(`${earlyMessages.length} messages arrived earlier than scheduled (tolerance: ${tolerance}ms)`);
                    earlyMessages.forEach(msg => {
                        const early = msg.scheduledTime - msg.receivedTime;
                        this.log(`  Message ${msg.id}: arrived ${early.toFixed(2)}ms early`);
                    });
                } else {
                    this.log(`\n✅ NO TIMING VIOLATIONS: All messages respected the timestamp parameter`);
                }

                this.log('\n=== END REPORT ===\n');
            }

            clearLog() {
                document.getElementById('log').textContent = 'Log cleared...\n';
            }
        }

        // Initialize the tester when the page loads
        window.addEventListener('DOMContentLoaded', () => {
            new MIDITimestampTester();
        });
    </script>
</body>
</html>
